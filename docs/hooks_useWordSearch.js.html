<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: hooks/useWordSearch.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: hooks/useWordSearch.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { useState, useEffect, useMemo, useCallback } from 'react';
import { generateGrid } from '../utils/gridGenerator';
import { ALL_WORDS } from '../data/word';

/**
 * @module hooks/useWordSearch
 * @description Кастомний хук, що інкапсулює всю логіку гри Word Search:
 *              генерацію поля, виділення літер, перевірку слів, таймер та стан перемоги.
 */

/**
 * Хук useWordSearch — головна логіка гри «Пошук слів».
 *
 * @function useWordSearch
 * @param {Object} options — Параметри гри.
 * @param {number} [options.gridSize=5] — Розмір сітки (gridSize × gridSize).
 * @param {number} [options.wordCount=4] — Кількість слів для розміщення.
 * @returns {Object} Стан гри та обробники подій.
 * @returns {string[]} returns.grid — Масив літер (flatten-сітка).
 * @returns {string[]} returns.words — Розміщені слова.
 * @returns {string[]} returns.foundWords — Знайдені слова.
 * @returns {number[]} returns.selection — Індекси виділених клітинок.
 * @returns {string} returns.formattedTime — Час у форматі MM:SS.
 * @returns {boolean} returns.isGameWon — Чи виграна гра.
 * @returns {Function} returns.startGame — Функція для (пере)запуску гри.
 * @returns {Object} returns.eventHandlers — Обробники подій миші.
 */
export const useWordSearch = ({ gridSize = 5, wordCount = 4 }) => {
    const [grid, setGrid] = useState([]);
    const [words, setWords] = useState([]);
    const [foundWords, setFoundWords] = useState([]);

    const [selection, setSelection] = useState([]);
    const [isSelecting, setIsSelecting] = useState(false);
    const [selectionDirection, setSelectionDirection] = useState(null);

    const getCoords = useCallback((index) => ({
        row: Math.floor(index / gridSize),
        col: index % gridSize,
    }), [gridSize]);

    const [time, setTime] = useState(0);
    const [isGameActive, setIsGameActive] = useState(false);
    const [isGameWon, setIsGameWon] = useState(false);

    const startGame = useCallback(() => {
        const newWordsPool = [...ALL_WORDS].sort(() => 0.5 - Math.random());

        const wordsToPlace = newWordsPool.slice(0, wordCount);
        const { grid: newGrid, placedWords } = generateGrid(wordsToPlace, gridSize, wordCount);

        setWords(placedWords);
        setGrid(newGrid);

        setFoundWords([]);
        setSelection([]);
        setTime(0);
        setIsGameWon(false);
        setIsGameActive(true);
        setSelectionDirection(null);
    }, [gridSize, wordCount]);

    useEffect(() => {
        let interval;
        if (isGameActive) {
            interval = setInterval(() => {
                setTime(t => t + 1);
            }, 1000);
        }
        return () => clearInterval(interval);
    }, [isGameActive]);

    useEffect(() => {
        if (words.length > 0 &amp;&amp; foundWords.length === words.length) {
            setIsGameWon(true);
            setIsGameActive(false);
        }
    }, [foundWords, words]);


    const handleMouseDown = (index) => {
        setIsSelecting(true);
        setSelection([index]);
        setSelectionDirection(null);
    };

    const handleMouseEnter = (index) => {
        if (!isSelecting || selection.includes(index)) return;

        const lastIndex = selection[selection.length - 1];
        const coordsLast = getCoords(lastIndex);
        const coordsNew = getCoords(index);

        const diffRow = coordsNew.row - coordsLast.row;
        const diffCol = coordsNew.col - coordsLast.col;

        const isH_Adjacent = Math.abs(diffCol) === 1 &amp;&amp; diffRow === 0;
        const isV_Adjacent = Math.abs(diffRow) === 1 &amp;&amp; diffCol === 0;

        if (!isH_Adjacent &amp;&amp; !isV_Adjacent) return;

        if (selection.length === 1) {
            if (isH_Adjacent) setSelectionDirection('horizontal');
            if (isV_Adjacent) setSelectionDirection('vertical');
            setSelection([...selection, index]);
        } else {
            if (selectionDirection === 'horizontal' &amp;&amp; isH_Adjacent) {
                setSelection([...selection, index]);
            } else if (selectionDirection === 'vertical' &amp;&amp; isV_Adjacent) {
                setSelection([...selection, index]);
            }
        }
    };

    const handleMouseUp = () => {
        setIsSelecting(false);
        setSelectionDirection(null);

        const selectedWord = selection.map(index => grid[index]).join('');

        if (words.includes(selectedWord) &amp;&amp; !foundWords.includes(selectedWord)) {
            setFoundWords(prev => [...prev, selectedWord]);
        }

        setSelection([]);
    };

    const formattedTime = useMemo(() => {
        const minutes = Math.floor(time / 60).toString().padStart(2, '0');
        const seconds = (time % 60).toString().padStart(2, '0');
        return `${minutes}:${seconds}`;
    }, [time]);

    return {
        grid,
        words,
        foundWords,
        selection,
        formattedTime,
        isGameWon,
        startGame,
        eventHandlers: {
            onMouseDown: handleMouseDown,
            onMouseEnter: handleMouseEnter,
            onMouseUp: handleMouseUp,
        }
    };
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-App.html">App</a></li><li><a href="module-components_Game_LetterTile.html">components/Game/LetterTile</a></li><li><a href="module-components_Game_WordGrid.html">components/Game/WordGrid</a></li><li><a href="module-components_Game_WordList.html">components/Game/WordList</a></li><li><a href="module-components_UI_Button.html">components/UI/Button</a></li><li><a href="module-components_UI_Modal.html">components/UI/Modal</a></li><li><a href="module-hooks_useWordSearch.html">hooks/useWordSearch</a></li><li><a href="module-store_slices_leaderboardSlice.html">store/slices/leaderboardSlice</a></li><li><a href="module-store_slices_settingsSlice.html">store/slices/settingsSlice</a></li><li><a href="module-store_store.html">store/store</a></li><li><a href="module-utils_gridGenerator.html">utils/gridGenerator</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CookiePopup">CookiePopup</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Sat Feb 21 2026 10:42:19 GMT+0200 (за східноєвропейським стандартним часом)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
